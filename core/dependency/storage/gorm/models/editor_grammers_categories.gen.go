// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package models

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"river0825/cleanarchitecture/core/dependency/storage/gorm/table"
)

func newEditorGrammersCategorie(db *gorm.DB, opts ...gen.DOOption) editorGrammersCategorie {
	_editorGrammersCategorie := editorGrammersCategorie{}

	_editorGrammersCategorie.editorGrammersCategorieDo.UseDB(db, opts...)
	_editorGrammersCategorie.editorGrammersCategorieDo.UseModel(&table.EditorGrammersCategorie{})

	tableName := _editorGrammersCategorie.editorGrammersCategorieDo.TableName()
	_editorGrammersCategorie.ALL = field.NewAsterisk(tableName)
	_editorGrammersCategorie.ID = field.NewInt32(tableName, "id")
	_editorGrammersCategorie.EditorGrammerID = field.NewInt32(tableName, "editor_grammer_id")
	_editorGrammersCategorie.EditorCategoryGrammerID = field.NewInt32(tableName, "editor-category-grammer_id")

	_editorGrammersCategorie.fillFieldMap()

	return _editorGrammersCategorie
}

type editorGrammersCategorie struct {
	editorGrammersCategorieDo

	ALL                     field.Asterisk
	ID                      field.Int32
	EditorGrammerID         field.Int32
	EditorCategoryGrammerID field.Int32

	fieldMap map[string]field.Expr
}

func (e editorGrammersCategorie) Table(newTableName string) *editorGrammersCategorie {
	e.editorGrammersCategorieDo.UseTable(newTableName)
	return e.updateTableName(newTableName)
}

func (e editorGrammersCategorie) As(alias string) *editorGrammersCategorie {
	e.editorGrammersCategorieDo.DO = *(e.editorGrammersCategorieDo.As(alias).(*gen.DO))
	return e.updateTableName(alias)
}

func (e *editorGrammersCategorie) updateTableName(table string) *editorGrammersCategorie {
	e.ALL = field.NewAsterisk(table)
	e.ID = field.NewInt32(table, "id")
	e.EditorGrammerID = field.NewInt32(table, "editor_grammer_id")
	e.EditorCategoryGrammerID = field.NewInt32(table, "editor-category-grammer_id")

	e.fillFieldMap()

	return e
}

func (e *editorGrammersCategorie) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := e.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (e *editorGrammersCategorie) fillFieldMap() {
	e.fieldMap = make(map[string]field.Expr, 3)
	e.fieldMap["id"] = e.ID
	e.fieldMap["editor_grammer_id"] = e.EditorGrammerID
	e.fieldMap["editor-category-grammer_id"] = e.EditorCategoryGrammerID
}

func (e editorGrammersCategorie) clone(db *gorm.DB) editorGrammersCategorie {
	e.editorGrammersCategorieDo.ReplaceConnPool(db.Statement.ConnPool)
	return e
}

func (e editorGrammersCategorie) replaceDB(db *gorm.DB) editorGrammersCategorie {
	e.editorGrammersCategorieDo.ReplaceDB(db)
	return e
}

type editorGrammersCategorieDo struct{ gen.DO }

type IEditorGrammersCategorieDo interface {
	gen.SubQuery
	Debug() IEditorGrammersCategorieDo
	WithContext(ctx context.Context) IEditorGrammersCategorieDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IEditorGrammersCategorieDo
	WriteDB() IEditorGrammersCategorieDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IEditorGrammersCategorieDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IEditorGrammersCategorieDo
	Not(conds ...gen.Condition) IEditorGrammersCategorieDo
	Or(conds ...gen.Condition) IEditorGrammersCategorieDo
	Select(conds ...field.Expr) IEditorGrammersCategorieDo
	Where(conds ...gen.Condition) IEditorGrammersCategorieDo
	Order(conds ...field.Expr) IEditorGrammersCategorieDo
	Distinct(cols ...field.Expr) IEditorGrammersCategorieDo
	Omit(cols ...field.Expr) IEditorGrammersCategorieDo
	Join(table schema.Tabler, on ...field.Expr) IEditorGrammersCategorieDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IEditorGrammersCategorieDo
	RightJoin(table schema.Tabler, on ...field.Expr) IEditorGrammersCategorieDo
	Group(cols ...field.Expr) IEditorGrammersCategorieDo
	Having(conds ...gen.Condition) IEditorGrammersCategorieDo
	Limit(limit int) IEditorGrammersCategorieDo
	Offset(offset int) IEditorGrammersCategorieDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IEditorGrammersCategorieDo
	Unscoped() IEditorGrammersCategorieDo
	Create(values ...*table.EditorGrammersCategorie) error
	CreateInBatches(values []*table.EditorGrammersCategorie, batchSize int) error
	Save(values ...*table.EditorGrammersCategorie) error
	First() (*table.EditorGrammersCategorie, error)
	Take() (*table.EditorGrammersCategorie, error)
	Last() (*table.EditorGrammersCategorie, error)
	Find() ([]*table.EditorGrammersCategorie, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*table.EditorGrammersCategorie, err error)
	FindInBatches(result *[]*table.EditorGrammersCategorie, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*table.EditorGrammersCategorie) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IEditorGrammersCategorieDo
	Assign(attrs ...field.AssignExpr) IEditorGrammersCategorieDo
	Joins(fields ...field.RelationField) IEditorGrammersCategorieDo
	Preload(fields ...field.RelationField) IEditorGrammersCategorieDo
	FirstOrInit() (*table.EditorGrammersCategorie, error)
	FirstOrCreate() (*table.EditorGrammersCategorie, error)
	FindByPage(offset int, limit int) (result []*table.EditorGrammersCategorie, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IEditorGrammersCategorieDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (e editorGrammersCategorieDo) Debug() IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Debug())
}

func (e editorGrammersCategorieDo) WithContext(ctx context.Context) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.WithContext(ctx))
}

func (e editorGrammersCategorieDo) ReadDB() IEditorGrammersCategorieDo {
	return e.Clauses(dbresolver.Read)
}

func (e editorGrammersCategorieDo) WriteDB() IEditorGrammersCategorieDo {
	return e.Clauses(dbresolver.Write)
}

func (e editorGrammersCategorieDo) Session(config *gorm.Session) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Session(config))
}

func (e editorGrammersCategorieDo) Clauses(conds ...clause.Expression) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Clauses(conds...))
}

func (e editorGrammersCategorieDo) Returning(value interface{}, columns ...string) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Returning(value, columns...))
}

func (e editorGrammersCategorieDo) Not(conds ...gen.Condition) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Not(conds...))
}

func (e editorGrammersCategorieDo) Or(conds ...gen.Condition) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Or(conds...))
}

func (e editorGrammersCategorieDo) Select(conds ...field.Expr) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Select(conds...))
}

func (e editorGrammersCategorieDo) Where(conds ...gen.Condition) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Where(conds...))
}

func (e editorGrammersCategorieDo) Order(conds ...field.Expr) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Order(conds...))
}

func (e editorGrammersCategorieDo) Distinct(cols ...field.Expr) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Distinct(cols...))
}

func (e editorGrammersCategorieDo) Omit(cols ...field.Expr) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Omit(cols...))
}

func (e editorGrammersCategorieDo) Join(table schema.Tabler, on ...field.Expr) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Join(table, on...))
}

func (e editorGrammersCategorieDo) LeftJoin(table schema.Tabler, on ...field.Expr) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.LeftJoin(table, on...))
}

func (e editorGrammersCategorieDo) RightJoin(table schema.Tabler, on ...field.Expr) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.RightJoin(table, on...))
}

func (e editorGrammersCategorieDo) Group(cols ...field.Expr) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Group(cols...))
}

func (e editorGrammersCategorieDo) Having(conds ...gen.Condition) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Having(conds...))
}

func (e editorGrammersCategorieDo) Limit(limit int) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Limit(limit))
}

func (e editorGrammersCategorieDo) Offset(offset int) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Offset(offset))
}

func (e editorGrammersCategorieDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Scopes(funcs...))
}

func (e editorGrammersCategorieDo) Unscoped() IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Unscoped())
}

func (e editorGrammersCategorieDo) Create(values ...*table.EditorGrammersCategorie) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Create(values)
}

func (e editorGrammersCategorieDo) CreateInBatches(values []*table.EditorGrammersCategorie, batchSize int) error {
	return e.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (e editorGrammersCategorieDo) Save(values ...*table.EditorGrammersCategorie) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Save(values)
}

func (e editorGrammersCategorieDo) First() (*table.EditorGrammersCategorie, error) {
	if result, err := e.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*table.EditorGrammersCategorie), nil
	}
}

func (e editorGrammersCategorieDo) Take() (*table.EditorGrammersCategorie, error) {
	if result, err := e.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*table.EditorGrammersCategorie), nil
	}
}

func (e editorGrammersCategorieDo) Last() (*table.EditorGrammersCategorie, error) {
	if result, err := e.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*table.EditorGrammersCategorie), nil
	}
}

func (e editorGrammersCategorieDo) Find() ([]*table.EditorGrammersCategorie, error) {
	result, err := e.DO.Find()
	return result.([]*table.EditorGrammersCategorie), err
}

func (e editorGrammersCategorieDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*table.EditorGrammersCategorie, err error) {
	buf := make([]*table.EditorGrammersCategorie, 0, batchSize)
	err = e.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (e editorGrammersCategorieDo) FindInBatches(result *[]*table.EditorGrammersCategorie, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return e.DO.FindInBatches(result, batchSize, fc)
}

func (e editorGrammersCategorieDo) Attrs(attrs ...field.AssignExpr) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Attrs(attrs...))
}

func (e editorGrammersCategorieDo) Assign(attrs ...field.AssignExpr) IEditorGrammersCategorieDo {
	return e.withDO(e.DO.Assign(attrs...))
}

func (e editorGrammersCategorieDo) Joins(fields ...field.RelationField) IEditorGrammersCategorieDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Joins(_f))
	}
	return &e
}

func (e editorGrammersCategorieDo) Preload(fields ...field.RelationField) IEditorGrammersCategorieDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Preload(_f))
	}
	return &e
}

func (e editorGrammersCategorieDo) FirstOrInit() (*table.EditorGrammersCategorie, error) {
	if result, err := e.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*table.EditorGrammersCategorie), nil
	}
}

func (e editorGrammersCategorieDo) FirstOrCreate() (*table.EditorGrammersCategorie, error) {
	if result, err := e.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*table.EditorGrammersCategorie), nil
	}
}

func (e editorGrammersCategorieDo) FindByPage(offset int, limit int) (result []*table.EditorGrammersCategorie, count int64, err error) {
	result, err = e.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = e.Offset(-1).Limit(-1).Count()
	return
}

func (e editorGrammersCategorieDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = e.Count()
	if err != nil {
		return
	}

	err = e.Offset(offset).Limit(limit).Scan(result)
	return
}

func (e editorGrammersCategorieDo) Scan(result interface{}) (err error) {
	return e.DO.Scan(result)
}

func (e editorGrammersCategorieDo) Delete(models ...*table.EditorGrammersCategorie) (result gen.ResultInfo, err error) {
	return e.DO.Delete(models)
}

func (e *editorGrammersCategorieDo) withDO(do gen.Dao) *editorGrammersCategorieDo {
	e.DO = *do.(*gen.DO)
	return e
}
